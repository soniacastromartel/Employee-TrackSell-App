{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { MIN_VERSION_APP, PASS_FORMAT, BASE_UPDATE_LINK, BASE_URL, ANDROID_ENVIRONMENT_FILE_PATH, LOADING_CONTENT, UPDATE_ERROR, UPDATE_MAX_TIME_LOADING, ENVIRONMENT_FILENAME, IOS_ENVIRONMENT_FILEDIR_PATH, ERROR_WRITE_FILE, CONFIRMATION_DELETE_IOS_FILE, ERROR, FILE_NOT_EXISTS, SESION_EXPIRED, MAIL_TO, CC_MAIL, SUBJECT_MAIL, UPDATE_VALID, ANDROID_TYPE, IOS_TYPE, DOWNLOAD_VALID, ERROR_DOWNLOAD_UPDATE, ERROR_CANCEL_UPDATE, SERVER_NO_AVAILABLE, INFO_MODEL, INFO_UUID, INFO_MANUFACTURE, INFO_VERSION, INFO_SYSTEM, IC_ARROW_DOWN, IC_ARROW_UP, NONE, SCROLLING_TIME, DEFAULT_TIME_1S, COLLECTING_INFO, MAX_TIME_LOADING, NORMAL_TIME_WAIT, BASE_UPATE_IOS_PWA_LINK, REQUEST_IN_PROCESS } from '../app.constants';\nimport ApkUpdater from 'cordova-plugin-apkupdater';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./employee.service\";\nimport * as i2 from \"./notifications.service\";\nimport * as i3 from \"./access-to.service\";\nimport * as i4 from \"@ionic-native/app-version/ngx\";\nimport * as i5 from \"./datacheck.service\";\nimport * as i6 from \"@ionic/angular\";\nimport * as i7 from \"@ionic-native/in-app-browser/ngx\";\nimport * as i8 from \"@ionic-native/file/ngx\";\nimport * as i9 from \"./connection.service\";\nexport let UtilsService = /*#__PURE__*/(() => {\n  class UtilsService {\n    constructor(employeSvc, notification, accesstInfo, appVersion, checkSvc, platform, iab, file, connection) {\n      this.employeSvc = employeSvc;\n      this.notification = notification;\n      this.accesstInfo = accesstInfo;\n      this.appVersion = appVersion;\n      this.checkSvc = checkSvc;\n      this.platform = platform;\n      this.iab = iab;\n      this.file = file;\n      this.connection = connection;\n      // Variable de control para actualizacion pospuesta\n      this.pendingUpdate = false;\n      // Base Url\n      this.base = '';\n      // Options slide notices/promotions and images FAQ Viewew\n      this.slideOpts = {\n        initialSlide: 0,\n        speed: DEFAULT_TIME_1S\n      };\n    }\n    /**\n     * Metodo auxiliar para el control accesos\n     */\n    maxAccessPermited(accesos) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (accesos >= 3) {\n          this.employeSvc.employeeListener.next(undefined);\n          this.notification.alertBaseNotifications(SESION_EXPIRED.title, SESION_EXPIRED.msg);\n          // this.checkSvc.actionLog(LOG_TYPE[1], '[' + LOG_PLACE[0] + '] ' + SESION_EXPIRED.title, user.username + ' ' + user.pass);\n          return {\n            block: true\n          };\n        } else {\n          return true;\n        }\n      });\n    }\n    /* Recoge la versión actual de la app\n       * y en caso de error muestra la versión\n       * mínima.\n       */\n    getVersionApp() {\n      return __awaiter(this, void 0, void 0, function* () {\n        return yield this.appVersion.getVersionNumber().then(result => {\n          this.version = result;\n          return this.version;\n        }).catch(ex => {\n          this.version = MIN_VERSION_APP;\n          return this.version;\n        });\n      });\n    }\n    /**\n     * Escucha scroll y en función de 'direction' asigna el icono de flecha arriba o flecha abajo\n     *\n     * @param ev Evento touch\n     */\n    onScroll(ev, content) {\n      let direction;\n      if (ev.detail.deltaY > 0) {\n        direction = 1; //down\n      } else if (ev.detail.deltaY < 0) {\n        direction = 2; //up\n      }\n\n      switch (direction) {\n        case 1:\n          this.typeScroll = IC_ARROW_DOWN;\n          break;\n        case 2:\n          this.typeScroll = IC_ARROW_UP;\n          break;\n      }\n      this.detectBottom(content);\n    }\n    /**\n     * Scroll in lista de rankings\n     */\n    onScrolling(content) {\n      if (this.typeScroll !== NONE) {\n        if (this.typeScroll === IC_ARROW_UP) {\n          content.scrollToTop(SCROLLING_TIME);\n        } else {\n          content.scrollToBottom(SCROLLING_TIME);\n        }\n        setTimeout(() => {\n          this.typeScroll = NONE;\n        }, SCROLLING_TIME);\n      }\n    }\n    /**\n     * Detecta el final de página\n     */\n    detectBottom(content) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const scrollElement = yield content.getScrollElement();\n        if (scrollElement.scrollTop === scrollElement.scrollHeight - scrollElement.clientHeight) {\n          this.typeScroll = NONE;\n        }\n      });\n    }\n    /**\n     * Oculta el icono de flecha para\n     * subir o bajar de la lista\n     */\n    hiddenArrow() {\n      // eslint-disable-next-line eqeqeq\n      if (this.timeOutArrow != undefined) {\n        clearTimeout(this.timeOutArrow);\n      }\n      this.timeOutArrow = setTimeout(() => {\n        this.typeScroll = NONE;\n      }, 1500);\n    }\n    /**\n     * Creacion del objeto de informacion del dispositivo\n     *\n     * @param info Informacion a crear\n     * @returns Obj creado\n     */\n    createInfoData(info) {\n      return __awaiter(this, void 0, void 0, function* () {\n        return INFO_MODEL + info.modelo + INFO_UUID + info.uuid + INFO_VERSION + info.version + INFO_MANUFACTURE + info.fabricante + INFO_SYSTEM + info.os;\n      });\n    }\n    /**\n     * Send email\n     *\n     * @param to Destinatario\n     * @param subject Mensaje a enviar\n     */\n    sendMail(to, copy, subject) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const link = MAIL_TO + to + CC_MAIL + copy[0] + ', ' + copy[1] + SUBJECT_MAIL + subject;\n        this.iab.create(link, '_system').show();\n      });\n    }\n    /**\n     * Control de tiempo max para\n     * mantener una notification en\n     * pantalla\n     */\n    controlToNotifications(duration) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.timeControl !== undefined) {\n          clearTimeout(this.timeControl);\n        }\n        this.timeControl = setTimeout(() => {\n          this.notification.cancelLoad();\n        }, duration);\n      });\n    }\n    /**\n     * Cancela el control de tiempo\n     * excedido para notificaciones\n     */\n    cancelControlNotifications() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.timeControl !== undefined) {\n          clearTimeout(this.timeControl);\n        }\n      });\n    }\n    /**\n     * Metodo auxiliar para la creacion\n     * de error ocurrido y posterior\n     * storage\n     *\n     * @param ex Error ocurrido\n     * @param screen Pantalla ocurrido error\n     * @returns Objeto de error\n     */\n    createError(error, phone, screen) {\n      var _a, _b, _c, _d;\n      return __awaiter(this, void 0, void 0, function* () {\n        const uuid = (_a = this.accesstInfo.deviceInfo) === null || _a === void 0 ? void 0 : _a.uuid;\n        const model = (_b = this.accesstInfo.deviceInfo) === null || _b === void 0 ? void 0 : _b.modelo;\n        const version = (_c = this.accesstInfo.deviceInfo) === null || _c === void 0 ? void 0 : _c.version;\n        const fabricante = (_d = this.accesstInfo.deviceInfo) === null || _d === void 0 ? void 0 : _d.fabricante;\n        const er = {\n          phone,\n          uuid,\n          model,\n          version,\n          fabricante,\n          screen,\n          error,\n          fecha: new Date().toISOString()\n        };\n        return er;\n      });\n    }\n    /**\n     * Method auxiliar que valida el formato del dni\n     *\n     * @param dni Dni\n     * @returns Comprobación dni/nie\n     */\n    validateDni(dni) {\n      const nifRegex = /^[0-9]{8}[TRWAGMYFPDXBNJZSQVHLCKE]$/i;\n      const nieRegex = /^[XxTtYyZz]{1}[0-9]{7}[a-zA-Z]{1}$/i;\n      return nifRegex.test(dni) || nieRegex.test(dni);\n    }\n    /**\n     * Comprobacion de version instalada en el dispositivo\n     *\n     * @param tk Token employee\n     */\n    checkingUpdate(tk) {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.notification.loadingData(COLLECTING_INFO);\n        this.controlToNotifications(MAX_TIME_LOADING);\n        // Comprobacion de version actual instalada en dispositivo\n        yield this.checkSvc.checkingVersion(this.version, tk).then(result => {\n          const updateSubcription = result.subscribe(response => __awaiter(this, void 0, void 0, function* () {\n            if (response.data === UPDATE_VALID) {\n              // Comprobacion de omision de actualizacion de la app\n              yield this.checkNotUpdate().then(count => __awaiter(this, void 0, void 0, function* () {\n                let auxSub = count.subscribe(res => {\n                  // Si no ha omitido la descarga de actualizacion mas de 3 veces\n                  if (res.data < 30) {\n                    // Si está conectado al wifi se permite realizar la descarga\n                    if (this.connection.typeConnection()) {\n                      updateSubcription.unsubscribe();\n                      this.downloadingUpdate(false);\n                      this.pendingUpdate = false;\n                    } else {\n                      // En caso contrario se solicita conectar con wifi para\n                      // realizar la descarga\n                      this.notification.notAllowUpdate();\n                      this.pendingUpdate = true;\n                      this.checkNotUpdate(true).then(res => {\n                        res.subscribe();\n                      });\n                    }\n                  } else {\n                    this.downloadingUpdate(true);\n                    this.pendingUpdate = false;\n                  }\n                  auxSub.unsubscribe();\n                });\n              })).catch(ex => {\n                this.actionsCatch(ex);\n              });\n            } else {\n              this.checkSvc.resetUpdateCount(this.employeSvc.employee.username);\n              this.actionsCatch();\n            }\n          }));\n        }).catch(ex => {\n          this.actionsCatch(ex);\n        });\n      });\n    }\n    /**\n     * Muestra la alerta para la descarga y elige el camino\n     * adecuado en caso de confirmación\n     */\n    downloadingUpdate(forceUpdate) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this.notification.updateApp(forceUpdate).then(res => __awaiter(this, void 0, void 0, function* () {\n          if (res.role === DOWNLOAD_VALID) {\n            this.procesingUpdate();\n          } else {\n            this.checkNotUpdate(true).then(res => {\n              res.subscribe();\n            });\n            this.pendingUpdate = true;\n          }\n          this.notification.alertOp = false;\n        }));\n      });\n    }\n    /**\n     * Muestra el toast de solicitud de desbloqueo en curso\n     */\n    unlockRequested(isRequested) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this.notification.toastBaseInfo(REQUEST_IN_PROCESS.title, REQUEST_IN_PROCESS.msg, 'middle');\n      });\n    }\n    /**\n     * Gestion de actualiacion segun plataforma\n     */\n    procesingUpdate() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.notification.updatingApp();\n        try {\n          if (this.platform.is(ANDROID_TYPE)) {\n            yield this.checkSvc.getUpdateVersion(ANDROID_TYPE).then(version => {\n              version.subscribe(updateData => {\n                console.log(updateData);\n                console.log(updateData.message);\n                this.updateAndroidApp(updateData.message);\n              });\n            }).catch(ex => {\n              alert(ex);\n            });\n          } else if (this.platform.is(IOS_TYPE)) {\n            yield this.checkSvc.getUpdateVersion(IOS_TYPE).then(version => {\n              version.subscribe(updateData => {\n                this.updateIOSApp(updateData.message);\n              });\n            });\n          } else {\n            this.pendingUpdate = true;\n            this.notification.alertOp = false;\n          }\n        } catch (ex) {\n          this.notification.cancelLoad();\n          this.notification.baseThrowAlerts(ERROR.title, UPDATE_ERROR.msg);\n        }\n      });\n    }\n    /**\n     * Comprobacion patron password\n     *\n     * @param pass Pass a comprobar\n     * @returns Comprobacion\n     */\n    formatPass(pass) {\n      const res = pass.match(PASS_FORMAT);\n      return res !== null;\n    }\n    /**\n     * Actualizacion automática version app\n     */\n    updateAndroidApp(fileName) {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.base = this.checkSvc.base;\n        if (!this.notification.loadData) {\n          this.controlToNotifications(NORMAL_TIME_WAIT);\n          this.notification.loadingData(LOADING_CONTENT);\n        }\n        // Control extra para la descarga de actualizacion\n        const controlUpdate = setTimeout(() => {\n          ApkUpdater.stop();\n        }, UPDATE_MAX_TIME_LOADING);\n        yield ApkUpdater.download(this.base + BASE_UPDATE_LINK + fileName).then(res => __awaiter(this, void 0, void 0, function* () {\n          if (res !== undefined) {\n            this.notification.cancelLoad();\n            this.notification.loadingData(LOADING_CONTENT);\n            // Si en este punto llega ok (sin tardar) se cancela control extra\n            clearTimeout(controlUpdate);\n            // Se realiza la instalación y continúa el flujo normal\n            yield ApkUpdater.install(() => __awaiter(this, void 0, void 0, function* () {}), ex => {\n              var _a;\n              this.notification.baseThrowAlerts(ERROR_DOWNLOAD_UPDATE, ex);\n              this.createError(ex, (_a = this.employeSvc.employee) === null || _a === void 0 ? void 0 : _a.phone, 'UtilsService').then(result => {\n                this.checkSvc.setErrors(result, UtilsService);\n              });\n            });\n          }\n        })).then(() => {\n          this.notification.cancelLoad();\n        }).catch(ex => {\n          this.pendingUpdate = true;\n          this.notification.cancelLoad();\n          if (!ex.stack.startsWith(ERROR_CANCEL_UPDATE)) {\n            this.notification.baseThrowAlerts(UPDATE_ERROR.title, UPDATE_ERROR.msg);\n          } else {\n            this.notification.alertBaseNotifications(SERVER_NO_AVAILABLE.title, SERVER_NO_AVAILABLE.msg);\n          }\n        });\n      });\n    }\n    /**\n     * Actualizacion para la plataforma IOS\n     *\n     * NOTA: EL PARAM fileName NO SE UTILIZA HASTA VALIDAR\n     * LA APP DE APPLE, ACTUALMENTE PWA\n     */\n    updateIOSApp(fileName) {\n      const iosPath = BASE_URL + BASE_UPATE_IOS_PWA_LINK;\n      this.iab.create(iosPath).show();\n    }\n    /**\n     * Comprobacion de NO ACTUALIZACION\n     * (Se permitira que el usuario no actualice un maximo\n     * de 3 veces, si los supera se fuera la actualizacion).\n     */\n    checkNotUpdate(isSum = false) {\n      return __awaiter(this, void 0, void 0, function* () {\n        return yield this.checkSvc.notUpdate(this.employeSvc.employee.username, isSum).then(count => {\n          this.notification.cancelLoad();\n          this.cancelControlNotifications();\n          return count;\n        });\n      });\n    }\n    /**\n     * Comprobación de archivo environment pre/pro\n     */\n    checkExistsFile() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.platform.is(ANDROID_TYPE)) {\n          return this.file.checkFile(this.file.externalApplicationStorageDirectory + ANDROID_ENVIRONMENT_FILE_PATH, ENVIRONMENT_FILENAME).then(() => true).catch(() => false);\n        } else {\n          return yield this.file.checkFile(this.file.applicationStorageDirectory, IOS_ENVIRONMENT_FILEDIR_PATH + '/' + ENVIRONMENT_FILENAME).then(() => true).catch(() => false);\n        }\n      });\n    }\n    /**\n     * Lectura archivo\n     *\n     * @returns Contenido archivo\n     */\n    readFile(platform) {\n      return __awaiter(this, void 0, void 0, function* () {\n        let path;\n        if (platform === ANDROID_TYPE) {\n          path = this.file.externalApplicationStorageDirectory + ANDROID_ENVIRONMENT_FILE_PATH;\n        } else if (platform === IOS_TYPE) {\n          path = this.file.applicationStorageDirectory + IOS_ENVIRONMENT_FILEDIR_PATH;\n        }\n        return yield this.file.readAsText(path, ENVIRONMENT_FILENAME).then(content => content);\n      });\n    }\n    /**\n     * Crea un archivo txt con el contenido que recibe (SOLO PARA IOS)\n     */\n    createFileIOS(url) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this.file.listDir(this.file.applicationStorageDirectory, IOS_ENVIRONMENT_FILEDIR_PATH).then(collection => {\n          collection[0].getParent(parent => {\n            parent.getFile(ENVIRONMENT_FILENAME, {\n              create: true,\n              exclusive: false\n            }, data => {\n              if (data.isFile) {\n                data.createWriter(writter => {\n                  const environmentData = new Blob([url], {\n                    type: 'text/plain'\n                  });\n                  writter.write(environmentData);\n                  return true;\n                }, () => {\n                  this.notification.baseThrowAlerts(ERROR_WRITE_FILE.title, ERROR_WRITE_FILE.msg);\n                });\n              }\n            });\n          });\n        });\n      });\n    }\n    /**\n     * Realiza el borrado del archivo environment.txt en las\n     * distintas plataformas [ANDROID, IOS]\n     */\n    deleteIOSFile() {\n      return __awaiter(this, void 0, void 0, function* () {\n        try {\n          this.checkExistsFile().then(result => {\n            if (result) {\n              if (this.platform.is(IOS_TYPE)) {\n                this.file.removeFile(this.file.applicationStorageDirectory + IOS_ENVIRONMENT_FILEDIR_PATH, ENVIRONMENT_FILENAME).then(res => {\n                  if (res.success) {\n                    this.notification.alertBaseNotifications(CONFIRMATION_DELETE_IOS_FILE.title, CONFIRMATION_DELETE_IOS_FILE.msg);\n                  }\n                });\n              } else {\n                this.file.removeFile(this.file.externalApplicationStorageDirectory + ANDROID_ENVIRONMENT_FILE_PATH, ENVIRONMENT_FILENAME).then(res => {\n                  if (res.success) {\n                    this.notification.alertBaseNotifications(CONFIRMATION_DELETE_IOS_FILE.title, CONFIRMATION_DELETE_IOS_FILE.msg);\n                  }\n                });\n              }\n            } else {\n              this.notification.alertBaseNotifications(FILE_NOT_EXISTS.title, FILE_NOT_EXISTS.msg);\n            }\n          });\n        } catch (ex) {\n          this.notification.baseThrowAlerts(ERROR.title, ex);\n        }\n      });\n    }\n    /**\n    * App error Log\n    * Registro de eventos sucedidos en la App\n    *\n    * @param message Representa informacion adicional\n      * @param issue Representa la accion sucedida\n      * @param screen Pantalla donde ha sucedido\n    *\n    */\n    appActionLog(type, issue, message, screen) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const logRequest = {\n          type: type,\n          action: issue,\n          message: message,\n          channel: 'app',\n          screen: screen\n        };\n        this.checkSvc.logPost(logRequest);\n      });\n    }\n    appErrorLog(type, issue, message, screen) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const logRequest = {\n          type: type,\n          action: issue,\n          message: message,\n          channel: 'appError',\n          screen: screen\n        };\n        this.checkSvc.logPost(logRequest);\n      });\n    }\n    /**\n     * Metodo auxiliar para la gestion en caso de error con loading en curso (En catch)\n     * @param ex\n     */\n    actionsCatch(ex = null) {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.notification.cancelLoad();\n        this.cancelControlNotifications();\n        if (ex !== null) {\n          this.notification.baseThrowAlerts(ERROR.title, ex);\n        }\n      });\n    }\n  }\n  UtilsService.ɵfac = function UtilsService_Factory(t) {\n    return new (t || UtilsService)(i0.ɵɵinject(i1.EmployeeService), i0.ɵɵinject(i2.NotificationsService), i0.ɵɵinject(i3.AccessToService), i0.ɵɵinject(i4.AppVersion), i0.ɵɵinject(i5.DatacheckService), i0.ɵɵinject(i6.Platform), i0.ɵɵinject(i7.InAppBrowser), i0.ɵɵinject(i8.File), i0.ɵɵinject(i9.ConnectionService));\n  };\n  UtilsService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: UtilsService,\n    factory: UtilsService.ɵfac,\n    providedIn: 'root'\n  });\n  return UtilsService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}